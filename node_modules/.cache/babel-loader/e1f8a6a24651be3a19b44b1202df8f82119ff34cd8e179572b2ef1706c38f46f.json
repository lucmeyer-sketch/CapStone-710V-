{"ast":null,"code":"import { supabase } from '../supabaseClient';\n\n// interfaz extendida con información del estudiante y docente\n\n// interfaz para agrupar mensajes por conversación (docente)\n\n// interfaz para conversaciones del estudiante\n\n// crear un mensaje\nexport const crearMensaje = async mensaje => {\n  const {\n    data,\n    error\n  } = await supabase.from('mensajes').insert(mensaje).select().single();\n  if (error) throw error;\n  return data;\n};\n\n// obtener conversaciones del estudiante agrupadas por docente\nexport const getConversacionesEstudiante = async estudianteId => {\n  // obtener todos los mensajes del estudiante\n  const {\n    data: mensajes,\n    error\n  } = await supabase.from('mensajes').select('*').eq('estudiante_id', estudianteId).order('created_at', {\n    ascending: false\n  });\n  if (error) throw error;\n  if (!mensajes) return [];\n\n  // obtener IDs únicos de docentes\n  const docenteIds = Array.from(new Set(mensajes.filter(m => m.remitente_tipo === 'docente' || m.destinatario_tipo === 'docente').map(m => m.remitente_tipo === 'docente' ? m.remitente_id : m.destinatario_id).filter(id => id !== undefined)));\n\n  // obtener información de docentes\n  const {\n    data: docentes\n  } = await supabase.from('docentes').select('id, nombre, apellido, especialidad').in('id', docenteIds);\n  if (!docentes) return [];\n\n  // agrupar por docente\n  const conversacionesMap = new Map();\n  mensajes.forEach(msg => {\n    // identificar el docente en este mensaje\n    let docenteId;\n    if (msg.remitente_tipo === 'docente') {\n      docenteId = msg.remitente_id;\n    } else if (msg.destinatario_tipo === 'docente') {\n      docenteId = msg.destinatario_id;\n    }\n    if (!docenteId) return;\n    const docente = docentes.find(d => d.id === docenteId);\n    if (!docente) return;\n    if (!conversacionesMap.has(docenteId)) {\n      // determinar si está leído (si el estudiante es el destinatario y no está leído)\n      const esParaEstudiante = msg.destinatario_tipo === 'estudiante' && msg.estudiante_id === estudianteId;\n      conversacionesMap.set(docenteId, {\n        docente_id: docenteId,\n        docente_nombre: docente.nombre,\n        docente_apellido: docente.apellido,\n        docente_especialidad: docente.especialidad,\n        ultimo_mensaje: msg.mensaje,\n        ultimo_mensaje_fecha: msg.created_at,\n        ultimo_mensaje_tipo: msg.tipo || 'general',\n        mensajes_no_leidos: esParaEstudiante && !msg.leido ? 1 : 0,\n        total_mensajes: 1\n      });\n    } else {\n      const conv = conversacionesMap.get(docenteId);\n      conv.total_mensajes++;\n      const esParaEstudiante = msg.destinatario_tipo === 'estudiante' && msg.estudiante_id === estudianteId;\n      if (esParaEstudiante && !msg.leido) {\n        conv.mensajes_no_leidos++;\n      }\n    }\n  });\n  return Array.from(conversacionesMap.values()).sort((a, b) => new Date(b.ultimo_mensaje_fecha).getTime() - new Date(a.ultimo_mensaje_fecha).getTime());\n};\n\n// obtener todas las conversaciones agrupadas por estudiante (para docentes)\nexport const getConversaciones = async docenteId => {\n  // obtener todos los mensajes donde el docente es remitente\n  const {\n    data: mensajes,\n    error\n  } = await supabase.from('mensajes').select(`\n      *,\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\n        id,\n        nombre,\n        apellido,\n        grado,\n        seccion\n      )\n    `).eq('remitente_id', docenteId).not('estudiante_id', 'is', null).order('created_at', {\n    ascending: false\n  });\n  if (error) throw error;\n\n  // agrupar por estudiante\n  const conversacionesMap = new Map();\n  (mensajes || []).forEach(msg => {\n    if (!msg.estudiante) return;\n    const estudianteId = msg.estudiante.id;\n    if (!conversacionesMap.has(estudianteId)) {\n      conversacionesMap.set(estudianteId, {\n        estudiante_id: estudianteId,\n        estudiante_nombre: msg.estudiante.nombre,\n        estudiante_apellido: msg.estudiante.apellido,\n        estudiante_grado: msg.estudiante.grado,\n        estudiante_seccion: msg.estudiante.seccion,\n        ultimo_mensaje: msg.mensaje,\n        ultimo_mensaje_fecha: msg.created_at,\n        ultimo_mensaje_tipo: msg.tipo || 'general',\n        mensajes_no_leidos: msg.leido ? 0 : 1,\n        total_mensajes: 1\n      });\n    } else {\n      const conv = conversacionesMap.get(estudianteId);\n      conv.total_mensajes++;\n      if (!msg.leido) {\n        conv.mensajes_no_leidos++;\n      }\n    }\n  });\n  return Array.from(conversacionesMap.values()).sort((a, b) => new Date(b.ultimo_mensaje_fecha).getTime() - new Date(a.ultimo_mensaje_fecha).getTime());\n};\n\n// obtener mensajes de un estudiante específico (con información del docente)\nexport const getMensajesPorEstudiante = async estudianteId => {\n  // Primero obtenemos los mensajes\n  const {\n    data: mensajes,\n    error\n  } = await supabase.from('mensajes').select(`\n      *,\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\n        id,\n        nombre,\n        apellido,\n        grado,\n        seccion,\n        email\n      )\n    `).eq('estudiante_id', estudianteId).order('created_at', {\n    ascending: true\n  });\n  if (error) throw error;\n  if (!mensajes) return [];\n\n  // Obtener IDs únicos de docentes\n  const docenteIds = Array.from(new Set(mensajes.filter(m => m.remitente_tipo === 'docente').map(m => m.remitente_id)));\n\n  // Obtener información de docentes si hay\n  let docentes = [];\n  if (docenteIds.length > 0) {\n    const {\n      data: docentesData\n    } = await supabase.from('docentes').select('id, nombre, apellido, especialidad').in('id', docenteIds);\n    docentes = docentesData || [];\n  }\n\n  // Combinar la información\n  return mensajes.map(mensaje => ({\n    ...mensaje,\n    docente: mensaje.remitente_tipo === 'docente' ? docentes.find(d => d.id === mensaje.remitente_id) : undefined\n  }));\n};\n\n// obtener mensajes entre un docente y un estudiante específico (conversación privada)\nexport const getMensajesConversacionPrivada = async (docenteId, estudianteId) => {\n  // Obtener mensajes donde:\n  // 1. El estudiante es el destinatario Y el docente es el remitente\n  // 2. O el estudiante es el remitente (respuesta)\n  const {\n    data: mensajes,\n    error\n  } = await supabase.from('mensajes').select(`\n      *,\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\n        id,\n        nombre,\n        apellido,\n        grado,\n        seccion,\n        email\n      )\n    `).eq('estudiante_id', estudianteId).or(`and(remitente_tipo.eq.docente,remitente_id.eq.${docenteId}),and(remitente_tipo.eq.estudiante,remitente_id.eq.${estudianteId})`).order('created_at', {\n    ascending: true\n  });\n  if (error) throw error;\n  if (!mensajes) return [];\n\n  // Obtener información del docente\n  const {\n    data: docenteData\n  } = await supabase.from('docentes').select('id, nombre, apellido, especialidad').eq('id', docenteId).single();\n\n  // Agregar información del docente a los mensajes\n  return mensajes.map(mensaje => ({\n    ...mensaje,\n    docente: mensaje.remitente_tipo === 'docente' && mensaje.remitente_id === docenteId ? docenteData : undefined\n  }));\n};\n\n// obtener todos los mensajes del docente\nexport const getMensajesDocente = async docenteId => {\n  const {\n    data,\n    error\n  } = await supabase.from('mensajes').select(`\n      *,\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\n        id,\n        nombre,\n        apellido,\n        grado,\n        seccion,\n        email\n      )\n    `).eq('remitente_id', docenteId).order('created_at', {\n    ascending: false\n  });\n  if (error) throw error;\n  return data || [];\n};\n\n// marcar mensaje como leído\nexport const marcarComoLeido = async mensajeId => {\n  const {\n    error\n  } = await supabase.from('mensajes').update({\n    leido: true,\n    fecha_lectura: new Date().toISOString()\n  }).eq('id', mensajeId);\n  if (error) throw error;\n};\n\n// marcar todos los mensajes de una conversación específica como leídos\nexport const marcarConversacionLeida = async (estudianteId, docenteId) => {\n  let query = supabase.from('mensajes').update({\n    leido: true,\n    fecha_lectura: new Date().toISOString()\n  }).eq('estudiante_id', estudianteId).eq('leido', false);\n\n  // Si se proporciona docenteId, solo marcar mensajes de ese docente\n  if (docenteId) {\n    query = query.eq('remitente_id', docenteId);\n  }\n  const {\n    error\n  } = await query;\n  if (error) throw error;\n};\n\n// actualizar un mensaje\nexport const actualizarMensaje = async (id, cambios) => {\n  const {\n    data,\n    error\n  } = await supabase.from('mensajes').update(cambios).eq('id', id).select().single();\n  if (error) throw error;\n  return data;\n};\n\n// eliminar un mensaje\nexport const eliminarMensaje = async id => {\n  const {\n    error\n  } = await supabase.from('mensajes').delete().eq('id', id);\n  if (error) throw error;\n};\n\n// buscar mensajes\nexport const buscarMensajes = async (termino, docenteId) => {\n  const {\n    data,\n    error\n  } = await supabase.from('mensajes').select(`\n      *,\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\n        id,\n        nombre,\n        apellido,\n        grado,\n        seccion,\n        email\n      )\n    `).eq('remitente_id', docenteId).or(`asunto.ilike.%${termino}%,mensaje.ilike.%${termino}%`).order('created_at', {\n    ascending: false\n  });\n  if (error) throw error;\n  return data || [];\n};\n\n// obtener estadísticas de mensajería\nexport const getEstadisticasMensajes = async docenteId => {\n  const {\n    data: mensajes,\n    error\n  } = await supabase.from('mensajes').select('id, tipo, leido').eq('remitente_id', docenteId);\n  if (error) throw error;\n  const total = (mensajes === null || mensajes === void 0 ? void 0 : mensajes.length) || 0;\n  const noLeidos = (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => !m.leido).length) || 0;\n  const porTipo = {\n    general: (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => m.tipo === 'general').length) || 0,\n    urgente: (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => m.tipo === 'urgente').length) || 0,\n    academico: (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => m.tipo === 'academico').length) || 0,\n    conductual: (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => m.tipo === 'conductual').length) || 0,\n    felicitacion: (mensajes === null || mensajes === void 0 ? void 0 : mensajes.filter(m => m.tipo === 'felicitacion').length) || 0\n  };\n  return {\n    total,\n    noLeidos,\n    leidos: total - noLeidos,\n    porTipo\n  };\n};","map":{"version":3,"names":["supabase","crearMensaje","mensaje","data","error","from","insert","select","single","getConversacionesEstudiante","estudianteId","mensajes","eq","order","ascending","docenteIds","Array","Set","filter","m","remitente_tipo","destinatario_tipo","map","remitente_id","destinatario_id","id","undefined","docentes","in","conversacionesMap","Map","forEach","msg","docenteId","docente","find","d","has","esParaEstudiante","estudiante_id","set","docente_id","docente_nombre","nombre","docente_apellido","apellido","docente_especialidad","especialidad","ultimo_mensaje","ultimo_mensaje_fecha","created_at","ultimo_mensaje_tipo","tipo","mensajes_no_leidos","leido","total_mensajes","conv","get","values","sort","a","b","Date","getTime","getConversaciones","not","estudiante","estudiante_nombre","estudiante_apellido","estudiante_grado","grado","estudiante_seccion","seccion","getMensajesPorEstudiante","length","docentesData","getMensajesConversacionPrivada","or","docenteData","getMensajesDocente","marcarComoLeido","mensajeId","update","fecha_lectura","toISOString","marcarConversacionLeida","query","actualizarMensaje","cambios","eliminarMensaje","delete","buscarMensajes","termino","getEstadisticasMensajes","total","noLeidos","porTipo","general","urgente","academico","conductual","felicitacion","leidos"],"sources":["C:/Users/diego/OneDrive/Escritorio/ProyectoAPT/CapStone-710V-/src/services/mensajeService.ts"],"sourcesContent":["import { supabase } from '../supabaseClient';\r\nimport { Mensaje } from '../types/database';\r\n\r\n// interfaz extendida con información del estudiante y docente\r\nexport interface MensajeConDetalles extends Mensaje {\r\n  estudiante?: {\r\n    id: number;\r\n    nombre: string;\r\n    apellido: string;\r\n    grado?: string;\r\n    seccion?: string;\r\n    email?: string;\r\n  };\r\n  docente?: {\r\n    id: number;\r\n    nombre: string;\r\n    apellido: string;\r\n    especialidad?: string;\r\n  };\r\n}\r\n\r\n// interfaz para agrupar mensajes por conversación (docente)\r\nexport interface Conversacion {\r\n  estudiante_id: number;\r\n  estudiante_nombre: string;\r\n  estudiante_apellido: string;\r\n  estudiante_grado?: string;\r\n  estudiante_seccion?: string;\r\n  ultimo_mensaje: string;\r\n  ultimo_mensaje_fecha: string;\r\n  ultimo_mensaje_tipo: string;\r\n  mensajes_no_leidos: number;\r\n  total_mensajes: number;\r\n}\r\n\r\n// interfaz para conversaciones del estudiante\r\nexport interface ConversacionEstudiante {\r\n  docente_id: number;\r\n  docente_nombre: string;\r\n  docente_apellido: string;\r\n  docente_especialidad?: string;\r\n  ultimo_mensaje: string;\r\n  ultimo_mensaje_fecha: string;\r\n  ultimo_mensaje_tipo: string;\r\n  mensajes_no_leidos: number;\r\n  total_mensajes: number;\r\n}\r\n\r\n// crear un mensaje\r\nexport const crearMensaje = async (mensaje: Omit<Mensaje, 'id' | 'created_at'>): Promise<Mensaje> => {\r\n  const { data, error } = await supabase\r\n    .from('mensajes')\r\n    .insert(mensaje)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) throw error;\r\n  return data;\r\n};\r\n\r\n// obtener conversaciones del estudiante agrupadas por docente\r\nexport const getConversacionesEstudiante = async (estudianteId: number): Promise<ConversacionEstudiante[]> => {\r\n  // obtener todos los mensajes del estudiante\r\n  const { data: mensajes, error } = await supabase\r\n    .from('mensajes')\r\n    .select('*')\r\n    .eq('estudiante_id', estudianteId)\r\n    .order('created_at', { ascending: false });\r\n\r\n  if (error) throw error;\r\n  if (!mensajes) return [];\r\n\r\n  // obtener IDs únicos de docentes\r\n  const docenteIds = Array.from(new Set(\r\n    mensajes\r\n      .filter(m => m.remitente_tipo === 'docente' || m.destinatario_tipo === 'docente')\r\n      .map(m => m.remitente_tipo === 'docente' ? m.remitente_id : m.destinatario_id)\r\n      .filter(id => id !== undefined)\r\n  ));\r\n\r\n  // obtener información de docentes\r\n  const { data: docentes } = await supabase\r\n    .from('docentes')\r\n    .select('id, nombre, apellido, especialidad')\r\n    .in('id', docenteIds);\r\n\r\n  if (!docentes) return [];\r\n\r\n  // agrupar por docente\r\n  const conversacionesMap = new Map<number, ConversacionEstudiante>();\r\n\r\n  mensajes.forEach((msg: any) => {\r\n    // identificar el docente en este mensaje\r\n    let docenteId: number | undefined;\r\n    if (msg.remitente_tipo === 'docente') {\r\n      docenteId = msg.remitente_id;\r\n    } else if (msg.destinatario_tipo === 'docente') {\r\n      docenteId = msg.destinatario_id;\r\n    }\r\n\r\n    if (!docenteId) return;\r\n\r\n    const docente = docentes.find(d => d.id === docenteId);\r\n    if (!docente) return;\r\n\r\n    if (!conversacionesMap.has(docenteId)) {\r\n      // determinar si está leído (si el estudiante es el destinatario y no está leído)\r\n      const esParaEstudiante = msg.destinatario_tipo === 'estudiante' && msg.estudiante_id === estudianteId;\r\n      \r\n      conversacionesMap.set(docenteId, {\r\n        docente_id: docenteId,\r\n        docente_nombre: docente.nombre,\r\n        docente_apellido: docente.apellido,\r\n        docente_especialidad: docente.especialidad,\r\n        ultimo_mensaje: msg.mensaje,\r\n        ultimo_mensaje_fecha: msg.created_at,\r\n        ultimo_mensaje_tipo: msg.tipo || 'general',\r\n        mensajes_no_leidos: (esParaEstudiante && !msg.leido) ? 1 : 0,\r\n        total_mensajes: 1\r\n      });\r\n    } else {\r\n      const conv = conversacionesMap.get(docenteId)!;\r\n      conv.total_mensajes++;\r\n      \r\n      const esParaEstudiante = msg.destinatario_tipo === 'estudiante' && msg.estudiante_id === estudianteId;\r\n      if (esParaEstudiante && !msg.leido) {\r\n        conv.mensajes_no_leidos++;\r\n      }\r\n    }\r\n  });\r\n\r\n  return Array.from(conversacionesMap.values()).sort((a, b) => \r\n    new Date(b.ultimo_mensaje_fecha).getTime() - new Date(a.ultimo_mensaje_fecha).getTime()\r\n  );\r\n};\r\n\r\n// obtener todas las conversaciones agrupadas por estudiante (para docentes)\r\nexport const getConversaciones = async (docenteId: number): Promise<Conversacion[]> => {\r\n  // obtener todos los mensajes donde el docente es remitente\r\n  const { data: mensajes, error } = await supabase\r\n    .from('mensajes')\r\n    .select(`\r\n      *,\r\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\r\n        id,\r\n        nombre,\r\n        apellido,\r\n        grado,\r\n        seccion\r\n      )\r\n    `)\r\n    .eq('remitente_id', docenteId)\r\n    .not('estudiante_id', 'is', null)\r\n    .order('created_at', { ascending: false });\r\n\r\n  if (error) throw error;\r\n\r\n  // agrupar por estudiante\r\n  const conversacionesMap = new Map<number, Conversacion>();\r\n\r\n  (mensajes || []).forEach((msg: any) => {\r\n    if (!msg.estudiante) return;\r\n\r\n    const estudianteId = msg.estudiante.id;\r\n\r\n    if (!conversacionesMap.has(estudianteId)) {\r\n      conversacionesMap.set(estudianteId, {\r\n        estudiante_id: estudianteId,\r\n        estudiante_nombre: msg.estudiante.nombre,\r\n        estudiante_apellido: msg.estudiante.apellido,\r\n        estudiante_grado: msg.estudiante.grado,\r\n        estudiante_seccion: msg.estudiante.seccion,\r\n        ultimo_mensaje: msg.mensaje,\r\n        ultimo_mensaje_fecha: msg.created_at,\r\n        ultimo_mensaje_tipo: msg.tipo || 'general',\r\n        mensajes_no_leidos: msg.leido ? 0 : 1,\r\n        total_mensajes: 1\r\n      });\r\n    } else {\r\n      const conv = conversacionesMap.get(estudianteId)!;\r\n      conv.total_mensajes++;\r\n      if (!msg.leido) {\r\n        conv.mensajes_no_leidos++;\r\n      }\r\n    }\r\n  });\r\n\r\n  return Array.from(conversacionesMap.values()).sort((a, b) => \r\n    new Date(b.ultimo_mensaje_fecha).getTime() - new Date(a.ultimo_mensaje_fecha).getTime()\r\n  );\r\n};\r\n\r\n// obtener mensajes de un estudiante específico (con información del docente)\r\nexport const getMensajesPorEstudiante = async (\r\n  estudianteId: number\r\n): Promise<MensajeConDetalles[]> => {\r\n  // Primero obtenemos los mensajes\r\n  const { data: mensajes, error } = await supabase\r\n    .from('mensajes')\r\n    .select(`\r\n      *,\r\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\r\n        id,\r\n        nombre,\r\n        apellido,\r\n        grado,\r\n        seccion,\r\n        email\r\n      )\r\n    `)\r\n    .eq('estudiante_id', estudianteId)\r\n    .order('created_at', { ascending: true });\r\n\r\n  if (error) throw error;\r\n  if (!mensajes) return [];\r\n\r\n  // Obtener IDs únicos de docentes\r\n  const docenteIds = Array.from(new Set(\r\n    mensajes\r\n      .filter(m => m.remitente_tipo === 'docente')\r\n      .map(m => m.remitente_id)\r\n  ));\r\n\r\n  // Obtener información de docentes si hay\r\n  let docentes: any[] = [];\r\n  if (docenteIds.length > 0) {\r\n    const { data: docentesData } = await supabase\r\n      .from('docentes')\r\n      .select('id, nombre, apellido, especialidad')\r\n      .in('id', docenteIds);\r\n    \r\n    docentes = docentesData || [];\r\n  }\r\n\r\n  // Combinar la información\r\n  return mensajes.map(mensaje => ({\r\n    ...mensaje,\r\n    docente: mensaje.remitente_tipo === 'docente' \r\n      ? docentes.find(d => d.id === mensaje.remitente_id)\r\n      : undefined\r\n  }));\r\n};\r\n\r\n// obtener mensajes entre un docente y un estudiante específico (conversación privada)\r\nexport const getMensajesConversacionPrivada = async (\r\n  docenteId: number,\r\n  estudianteId: number\r\n): Promise<MensajeConDetalles[]> => {\r\n  // Obtener mensajes donde:\r\n  // 1. El estudiante es el destinatario Y el docente es el remitente\r\n  // 2. O el estudiante es el remitente (respuesta)\r\n  const { data: mensajes, error } = await supabase\r\n    .from('mensajes')\r\n    .select(`\r\n      *,\r\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\r\n        id,\r\n        nombre,\r\n        apellido,\r\n        grado,\r\n        seccion,\r\n        email\r\n      )\r\n    `)\r\n    .eq('estudiante_id', estudianteId)\r\n    .or(`and(remitente_tipo.eq.docente,remitente_id.eq.${docenteId}),and(remitente_tipo.eq.estudiante,remitente_id.eq.${estudianteId})`)\r\n    .order('created_at', { ascending: true });\r\n\r\n  if (error) throw error;\r\n  if (!mensajes) return [];\r\n\r\n  // Obtener información del docente\r\n  const { data: docenteData } = await supabase\r\n    .from('docentes')\r\n    .select('id, nombre, apellido, especialidad')\r\n    .eq('id', docenteId)\r\n    .single();\r\n\r\n  // Agregar información del docente a los mensajes\r\n  return mensajes.map(mensaje => ({\r\n    ...mensaje,\r\n    docente: mensaje.remitente_tipo === 'docente' && mensaje.remitente_id === docenteId\r\n      ? docenteData\r\n      : undefined\r\n  }));\r\n};\r\n\r\n// obtener todos los mensajes del docente\r\nexport const getMensajesDocente = async (docenteId: number): Promise<MensajeConDetalles[]> => {\r\n  const { data, error } = await supabase\r\n    .from('mensajes')\r\n    .select(`\r\n      *,\r\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\r\n        id,\r\n        nombre,\r\n        apellido,\r\n        grado,\r\n        seccion,\r\n        email\r\n      )\r\n    `)\r\n    .eq('remitente_id', docenteId)\r\n    .order('created_at', { ascending: false });\r\n\r\n  if (error) throw error;\r\n  return data || [];\r\n};\r\n\r\n// marcar mensaje como leído\r\nexport const marcarComoLeido = async (mensajeId: number): Promise<void> => {\r\n  const { error } = await supabase\r\n    .from('mensajes')\r\n    .update({ \r\n      leido: true,\r\n      fecha_lectura: new Date().toISOString()\r\n    })\r\n    .eq('id', mensajeId);\r\n\r\n  if (error) throw error;\r\n};\r\n\r\n// marcar todos los mensajes de una conversación específica como leídos\r\nexport const marcarConversacionLeida = async (\r\n  estudianteId: number,\r\n  docenteId?: number\r\n): Promise<void> => {\r\n  let query = supabase\r\n    .from('mensajes')\r\n    .update({ \r\n      leido: true,\r\n      fecha_lectura: new Date().toISOString()\r\n    })\r\n    .eq('estudiante_id', estudianteId)\r\n    .eq('leido', false);\r\n\r\n  // Si se proporciona docenteId, solo marcar mensajes de ese docente\r\n  if (docenteId) {\r\n    query = query.eq('remitente_id', docenteId);\r\n  }\r\n\r\n  const { error } = await query;\r\n  if (error) throw error;\r\n};\r\n\r\n// actualizar un mensaje\r\nexport const actualizarMensaje = async (\r\n  id: number,\r\n  cambios: Partial<Mensaje>\r\n): Promise<Mensaje> => {\r\n  const { data, error } = await supabase\r\n    .from('mensajes')\r\n    .update(cambios)\r\n    .eq('id', id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) throw error;\r\n  return data;\r\n};\r\n\r\n// eliminar un mensaje\r\nexport const eliminarMensaje = async (id: number): Promise<void> => {\r\n  const { error } = await supabase\r\n    .from('mensajes')\r\n    .delete()\r\n    .eq('id', id);\r\n\r\n  if (error) throw error;\r\n};\r\n\r\n// buscar mensajes\r\nexport const buscarMensajes = async (\r\n  termino: string,\r\n  docenteId: number\r\n): Promise<MensajeConDetalles[]> => {\r\n  const { data, error } = await supabase\r\n    .from('mensajes')\r\n    .select(`\r\n      *,\r\n      estudiante:Estudiantes!mensajes_estudiante_id_fkey (\r\n        id,\r\n        nombre,\r\n        apellido,\r\n        grado,\r\n        seccion,\r\n        email\r\n      )\r\n    `)\r\n    .eq('remitente_id', docenteId)\r\n    .or(`asunto.ilike.%${termino}%,mensaje.ilike.%${termino}%`)\r\n    .order('created_at', { ascending: false });\r\n\r\n  if (error) throw error;\r\n  return data || [];\r\n};\r\n\r\n// obtener estadísticas de mensajería\r\nexport const getEstadisticasMensajes = async (docenteId: number) => {\r\n  const { data: mensajes, error } = await supabase\r\n    .from('mensajes')\r\n    .select('id, tipo, leido')\r\n    .eq('remitente_id', docenteId);\r\n\r\n  if (error) throw error;\r\n\r\n  const total = mensajes?.length || 0;\r\n  const noLeidos = mensajes?.filter(m => !m.leido).length || 0;\r\n  const porTipo = {\r\n    general: mensajes?.filter(m => m.tipo === 'general').length || 0,\r\n    urgente: mensajes?.filter(m => m.tipo === 'urgente').length || 0,\r\n    academico: mensajes?.filter(m => m.tipo === 'academico').length || 0,\r\n    conductual: mensajes?.filter(m => m.tipo === 'conductual').length || 0,\r\n    felicitacion: mensajes?.filter(m => m.tipo === 'felicitacion').length || 0\r\n  };\r\n\r\n  return {\r\n    total,\r\n    noLeidos,\r\n    leidos: total - noLeidos,\r\n    porTipo\r\n  };\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}