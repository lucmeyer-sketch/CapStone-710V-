{"ast":null,"code":"import { supabase } from '../supabaseClient';\n// generar reporte de asistencia\nexport const generarReporteAsistencia = async (fechaInicio, fechaFin, grado, seccion, gradosPermitidos, seccionesPermitidas) => {\n  try {\n    // determinar estudiantes válidos según filtros y permisos\n    let estudiantesQuery = supabase.from('Estudiantes').select('id, grado, seccion');\n    if (grado) estudiantesQuery = estudiantesQuery.eq('grado', grado);\n    if (seccion) estudiantesQuery = estudiantesQuery.eq('seccion', seccion);\n    if (gradosPermitidos && gradosPermitidos.length > 0) {\n      estudiantesQuery = estudiantesQuery.in('grado', gradosPermitidos);\n    }\n    if (seccionesPermitidas && seccionesPermitidas.length > 0) {\n      estudiantesQuery = estudiantesQuery.in('seccion', seccionesPermitidas);\n    }\n    const {\n      data: estudiantesFiltrados,\n      error: estudiantesError\n    } = await estudiantesQuery;\n    if (estudiantesError) throw estudiantesError;\n    const idsFiltrados = (estudiantesFiltrados || []).map(e => e.id);\n\n    // obtener asistencias del período para los estudiantes permitidos\n    let query = supabase.from('asistencia').select(`\n        *,\n        estudiante:Estudiantes (\n          nombre,\n          apellido,\n          grado,\n          seccion\n        )\n      `).gte('fecha', fechaInicio).lte('fecha', fechaFin);\n    if (idsFiltrados.length > 0) {\n      query = query.in('estudiante_id', idsFiltrados);\n    }\n    const {\n      data: asistencias,\n      error\n    } = await query;\n    if (error) throw error;\n\n    // calcular estadísticas por estudiante\n    const estudiantesStats = new Map();\n    let presente = 0;\n    let tarde = 0;\n    let ausente = 0;\n    let justificado = 0;\n    asistencias === null || asistencias === void 0 ? void 0 : asistencias.forEach(asistencia => {\n      const estudianteId = asistencia.estudiante_id;\n      if (!estudiantesStats.has(estudianteId)) {\n        estudiantesStats.set(estudianteId, {\n          estudiante: asistencia.estudiante,\n          presente: 0,\n          ausente: 0,\n          tarde: 0,\n          justificado: 0,\n          total: 0\n        });\n      }\n      const studentStats = estudiantesStats.get(estudianteId);\n      studentStats[asistencia.estado]++;\n      studentStats.total++;\n\n      // acumular totales generales\n      if (asistencia.estado === 'presente') presente++;\n      if (asistencia.estado === 'tarde') tarde++;\n      if (asistencia.estado === 'ausente') ausente++;\n      if (asistencia.estado === 'justificado') justificado++;\n    });\n    const totalGeneral = presente + tarde + ausente + justificado;\n    const porcentajeAsistencia = totalGeneral > 0 ? Math.round((presente + tarde) / totalGeneral * 1000) / 10 : 0;\n    return {\n      periodo: {\n        fechaInicio,\n        fechaFin\n      },\n      filtros: {\n        grado,\n        seccion,\n        gradosAplicados: gradosPermitidos,\n        seccionesAplicadas: seccionesPermitidas\n      },\n      estadisticasGenerales: {\n        presente,\n        tarde,\n        ausente,\n        justificado,\n        total: totalGeneral,\n        porcentajeAsistencia\n      },\n      porEstudiante: Array.from(estudiantesStats.values()),\n      totalRegistros: (asistencias === null || asistencias === void 0 ? void 0 : asistencias.length) || 0\n    };\n  } catch (error) {\n    console.error('Error generando reporte de asistencia:', error);\n    throw error;\n  }\n};\n\n// generar reporte académico\nexport const generarReporteAcademico = async (grado, seccion, gradosPermitidos, seccionesPermitidas) => {\n  try {\n    // obtener estudiantes\n    let query = supabase.from('Estudiantes').select('*');\n    if (grado) query = query.eq('grado', grado);\n    if (seccion) query = query.eq('seccion', seccion);\n    if (gradosPermitidos && gradosPermitidos.length > 0) {\n      query = query.in('grado', gradosPermitidos);\n    }\n    if (seccionesPermitidas && seccionesPermitidas.length > 0) {\n      query = query.in('seccion', seccionesPermitidas);\n    }\n    const {\n      data: estudiantes,\n      error: estudiantesError\n    } = await query;\n    if (estudiantesError) throw estudiantesError;\n\n    // obtener calificaciones para cada estudiante\n    const estudiantesConNotas = await Promise.all((estudiantes || []).map(async estudiante => {\n      const {\n        data: calificaciones\n      } = await supabase.from('calificaciones').select(`\n            *,\n            clase:clases (\n              materia:materias (\n                nombre,\n                codigo\n              )\n            )\n          `).eq('estudiante_id', estudiante.id);\n\n      // calcular promedio general\n      const promedio = calificaciones && calificaciones.length > 0 ? (calificaciones.reduce((sum, cal) => sum + cal.nota, 0) / calificaciones.length).toFixed(1) : 0;\n\n      // calcular promedios por materia\n      const promediosPorMateria = new Map();\n      calificaciones === null || calificaciones === void 0 ? void 0 : calificaciones.forEach(cal => {\n        var _cal$clase, _cal$clase$materia;\n        const materiaNombre = ((_cal$clase = cal.clase) === null || _cal$clase === void 0 ? void 0 : (_cal$clase$materia = _cal$clase.materia) === null || _cal$clase$materia === void 0 ? void 0 : _cal$clase$materia.nombre) || 'Sin materia';\n        if (!promediosPorMateria.has(materiaNombre)) {\n          promediosPorMateria.set(materiaNombre, {\n            suma: 0,\n            count: 0\n          });\n        }\n        const materia = promediosPorMateria.get(materiaNombre);\n        materia.suma += cal.nota;\n        materia.count++;\n      });\n      const materias = Array.from(promediosPorMateria.entries()).map(([nombre, data]) => ({\n        materia: nombre,\n        promedio: (data.suma / data.count).toFixed(1),\n        evaluaciones: data.count\n      }));\n      return {\n        estudiante: {\n          nombre: estudiante.nombre,\n          apellido: estudiante.apellido,\n          grado: estudiante.grado,\n          seccion: estudiante.seccion\n        },\n        promedioGeneral: promedio,\n        totalEvaluaciones: (calificaciones === null || calificaciones === void 0 ? void 0 : calificaciones.length) || 0,\n        materias\n      };\n    }));\n\n    // calcular estadísticas generales\n    const promediosCurso = estudiantesConNotas.map(e => parseFloat(e.promedioGeneral));\n    const promedioGeneralCurso = promediosCurso.length > 0 ? (promediosCurso.reduce((sum, p) => sum + p, 0) / promediosCurso.length).toFixed(1) : 0;\n    return {\n      filtros: {\n        grado,\n        seccion\n      },\n      estadisticasGenerales: {\n        totalEstudiantes: (estudiantes === null || estudiantes === void 0 ? void 0 : estudiantes.length) || 0,\n        promedioGeneralCurso,\n        promedioMasAlto: Math.max(...promediosCurso, 0).toFixed(1),\n        promedioMasBajo: Math.min(...promediosCurso, 7.0).toFixed(1)\n      },\n      estudiantes: estudiantesConNotas\n    };\n  } catch (error) {\n    console.error('Error generando reporte académico:', error);\n    throw error;\n  }\n};\n\n// obtener lista de reportes guardados (simulado por ahora)\nexport const obtenerReportesGuardados = async () => {\n  // por ahora retornamos reportes de ejemplo\n  // en el futuro podrías guardar los reportes en la tabla 'reportes' de la BD\n  return [{\n    id: 1,\n    titulo: 'Reporte de Asistencia - Último Mes',\n    tipo: 'asistencia',\n    fecha_generacion: new Date().toISOString(),\n    periodo: 'Noviembre 2024',\n    datos: {}\n  }, {\n    id: 2,\n    titulo: 'Reporte Académico - 10° A',\n    tipo: 'academico',\n    fecha_generacion: new Date().toISOString(),\n    periodo: '2024',\n    grado: '10°',\n    seccion: 'A',\n    datos: {}\n  }];\n};\n\n// guardar reporte en la base de datos\nexport const guardarReporte = async (titulo, tipo, periodo, contenido) => {\n  const {\n    error\n  } = await supabase.from('reportes').insert({\n    titulo,\n    tipo_reporte: tipo,\n    periodo,\n    contenido: JSON.stringify(contenido),\n    generado_por_tipo: 'sistema'\n  });\n  if (error) throw error;\n};","map":{"version":3,"names":["supabase","generarReporteAsistencia","fechaInicio","fechaFin","grado","seccion","gradosPermitidos","seccionesPermitidas","estudiantesQuery","from","select","eq","length","in","data","estudiantesFiltrados","error","estudiantesError","idsFiltrados","map","e","id","query","gte","lte","asistencias","estudiantesStats","Map","presente","tarde","ausente","justificado","forEach","asistencia","estudianteId","estudiante_id","has","set","estudiante","total","studentStats","get","estado","totalGeneral","porcentajeAsistencia","Math","round","periodo","filtros","gradosAplicados","seccionesAplicadas","estadisticasGenerales","porEstudiante","Array","values","totalRegistros","console","generarReporteAcademico","estudiantes","estudiantesConNotas","Promise","all","calificaciones","promedio","reduce","sum","cal","nota","toFixed","promediosPorMateria","_cal$clase","_cal$clase$materia","materiaNombre","clase","materia","nombre","suma","count","materias","entries","evaluaciones","apellido","promedioGeneral","totalEvaluaciones","promediosCurso","parseFloat","promedioGeneralCurso","p","totalEstudiantes","promedioMasAlto","max","promedioMasBajo","min","obtenerReportesGuardados","titulo","tipo","fecha_generacion","Date","toISOString","datos","guardarReporte","contenido","insert","tipo_reporte","JSON","stringify","generado_por_tipo"],"sources":["C:/Users/diego/OneDrive/Escritorio/ProyectoAPT/CapStone-710V-/Proyecto/src/services/reporteService.ts"],"sourcesContent":["import { supabase } from '../supabaseClient';\r\nimport { getEstadisticasAsistencia } from './asistenciaService';\r\nimport { getPromedioGeneralEstudiante } from './calificacionService';\r\n\r\nexport interface ReporteGenerado {\r\n  id: number;\r\n  titulo: string;\r\n  tipo: 'asistencia' | 'academico' | 'conductual' | 'general';\r\n  fecha_generacion: string;\r\n  periodo: string;\r\n  grado?: string;\r\n  seccion?: string;\r\n  datos: any;\r\n}\r\n\r\n// generar reporte de asistencia\r\nexport const generarReporteAsistencia = async (\r\n  fechaInicio: string,\r\n  fechaFin: string,\r\n  grado?: string,\r\n  seccion?: string,\r\n  gradosPermitidos?: string[],\r\n  seccionesPermitidas?: string[]\r\n): Promise<any> => {\r\n  try {\r\n    // determinar estudiantes válidos según filtros y permisos\r\n    let estudiantesQuery = supabase\r\n      .from('Estudiantes')\r\n      .select('id, grado, seccion');\r\n\r\n    if (grado) estudiantesQuery = estudiantesQuery.eq('grado', grado);\r\n    if (seccion) estudiantesQuery = estudiantesQuery.eq('seccion', seccion);\r\n    if (gradosPermitidos && gradosPermitidos.length > 0) {\r\n      estudiantesQuery = estudiantesQuery.in('grado', gradosPermitidos);\r\n    }\r\n    if (seccionesPermitidas && seccionesPermitidas.length > 0) {\r\n      estudiantesQuery = estudiantesQuery.in('seccion', seccionesPermitidas);\r\n    }\r\n\r\n    const { data: estudiantesFiltrados, error: estudiantesError } = await estudiantesQuery;\r\n    if (estudiantesError) throw estudiantesError;\r\n\r\n    const idsFiltrados = (estudiantesFiltrados || []).map((e) => e.id);\r\n\r\n    // obtener asistencias del período para los estudiantes permitidos\r\n    let query = supabase\r\n      .from('asistencia')\r\n      .select(`\r\n        *,\r\n        estudiante:Estudiantes (\r\n          nombre,\r\n          apellido,\r\n          grado,\r\n          seccion\r\n        )\r\n      `)\r\n      .gte('fecha', fechaInicio)\r\n      .lte('fecha', fechaFin);\r\n\r\n    if (idsFiltrados.length > 0) {\r\n      query = query.in('estudiante_id', idsFiltrados);\r\n    }\r\n\r\n    const { data: asistencias, error } = await query;\r\n    if (error) throw error;\r\n\r\n    // calcular estadísticas por estudiante\r\n    const estudiantesStats = new Map();\r\n    let presente = 0;\r\n    let tarde = 0;\r\n    let ausente = 0;\r\n    let justificado = 0;\r\n\r\n    asistencias?.forEach(asistencia => {\r\n      const estudianteId = asistencia.estudiante_id;\r\n      if (!estudiantesStats.has(estudianteId)) {\r\n        estudiantesStats.set(estudianteId, {\r\n          estudiante: asistencia.estudiante,\r\n          presente: 0,\r\n          ausente: 0,\r\n          tarde: 0,\r\n          justificado: 0,\r\n          total: 0\r\n        });\r\n      }\r\n      const studentStats = estudiantesStats.get(estudianteId);\r\n      studentStats[asistencia.estado]++;\r\n      studentStats.total++;\r\n\r\n      // acumular totales generales\r\n      if (asistencia.estado === 'presente') presente++;\r\n      if (asistencia.estado === 'tarde') tarde++;\r\n      if (asistencia.estado === 'ausente') ausente++;\r\n      if (asistencia.estado === 'justificado') justificado++;\r\n    });\r\n\r\n    const totalGeneral = presente + tarde + ausente + justificado;\r\n    const porcentajeAsistencia = totalGeneral > 0\r\n      ? Math.round(((presente + tarde) / totalGeneral) * 1000) / 10\r\n      : 0;\r\n\r\n    return {\r\n      periodo: { fechaInicio, fechaFin },\r\n      filtros: { \r\n        grado, \r\n        seccion,\r\n        gradosAplicados: gradosPermitidos,\r\n        seccionesAplicadas: seccionesPermitidas\r\n      },\r\n      estadisticasGenerales: {\r\n        presente,\r\n        tarde,\r\n        ausente,\r\n        justificado,\r\n        total: totalGeneral,\r\n        porcentajeAsistencia\r\n      },\r\n      porEstudiante: Array.from(estudiantesStats.values()),\r\n      totalRegistros: asistencias?.length || 0\r\n    };\r\n  } catch (error) {\r\n    console.error('Error generando reporte de asistencia:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// generar reporte académico\r\nexport const generarReporteAcademico = async (\r\n  grado?: string,\r\n  seccion?: string,\r\n  gradosPermitidos?: string[],\r\n  seccionesPermitidas?: string[]\r\n): Promise<any> => {\r\n  try {\r\n    // obtener estudiantes\r\n    let query = supabase.from('Estudiantes').select('*');\r\n    \r\n    if (grado) query = query.eq('grado', grado);\r\n    if (seccion) query = query.eq('seccion', seccion);\r\n    if (gradosPermitidos && gradosPermitidos.length > 0) {\r\n      query = query.in('grado', gradosPermitidos);\r\n    }\r\n    if (seccionesPermitidas && seccionesPermitidas.length > 0) {\r\n      query = query.in('seccion', seccionesPermitidas);\r\n    }\r\n\r\n    const { data: estudiantes, error: estudiantesError } = await query;\r\n    if (estudiantesError) throw estudiantesError;\r\n\r\n    // obtener calificaciones para cada estudiante\r\n    const estudiantesConNotas = await Promise.all(\r\n      (estudiantes || []).map(async (estudiante) => {\r\n        const { data: calificaciones } = await supabase\r\n          .from('calificaciones')\r\n          .select(`\r\n            *,\r\n            clase:clases (\r\n              materia:materias (\r\n                nombre,\r\n                codigo\r\n              )\r\n            )\r\n          `)\r\n          .eq('estudiante_id', estudiante.id);\r\n\r\n        // calcular promedio general\r\n        const promedio = calificaciones && calificaciones.length > 0\r\n          ? (calificaciones.reduce((sum, cal) => sum + cal.nota, 0) / calificaciones.length).toFixed(1)\r\n          : 0;\r\n\r\n        // calcular promedios por materia\r\n        const promediosPorMateria = new Map();\r\n        calificaciones?.forEach(cal => {\r\n          const materiaNombre = cal.clase?.materia?.nombre || 'Sin materia';\r\n          if (!promediosPorMateria.has(materiaNombre)) {\r\n            promediosPorMateria.set(materiaNombre, { suma: 0, count: 0 });\r\n          }\r\n          const materia = promediosPorMateria.get(materiaNombre);\r\n          materia.suma += cal.nota;\r\n          materia.count++;\r\n        });\r\n\r\n        const materias = Array.from(promediosPorMateria.entries()).map(([nombre, data]) => ({\r\n          materia: nombre,\r\n          promedio: (data.suma / data.count).toFixed(1),\r\n          evaluaciones: data.count\r\n        }));\r\n\r\n        return {\r\n          estudiante: {\r\n            nombre: estudiante.nombre,\r\n            apellido: estudiante.apellido,\r\n            grado: estudiante.grado,\r\n            seccion: estudiante.seccion\r\n          },\r\n          promedioGeneral: promedio,\r\n          totalEvaluaciones: calificaciones?.length || 0,\r\n          materias\r\n        };\r\n      })\r\n    );\r\n\r\n    // calcular estadísticas generales\r\n    const promediosCurso = estudiantesConNotas.map(e => parseFloat(e.promedioGeneral as string));\r\n    const promedioGeneralCurso = promediosCurso.length > 0\r\n      ? (promediosCurso.reduce((sum, p) => sum + p, 0) / promediosCurso.length).toFixed(1)\r\n      : 0;\r\n\r\n    return {\r\n      filtros: { grado, seccion },\r\n      estadisticasGenerales: {\r\n        totalEstudiantes: estudiantes?.length || 0,\r\n        promedioGeneralCurso,\r\n        promedioMasAlto: Math.max(...promediosCurso, 0).toFixed(1),\r\n        promedioMasBajo: Math.min(...promediosCurso, 7.0).toFixed(1)\r\n      },\r\n      estudiantes: estudiantesConNotas\r\n    };\r\n  } catch (error) {\r\n    console.error('Error generando reporte académico:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// obtener lista de reportes guardados (simulado por ahora)\r\nexport const obtenerReportesGuardados = async (): Promise<ReporteGenerado[]> => {\r\n  // por ahora retornamos reportes de ejemplo\r\n  // en el futuro podrías guardar los reportes en la tabla 'reportes' de la BD\r\n  return [\r\n    {\r\n      id: 1,\r\n      titulo: 'Reporte de Asistencia - Último Mes',\r\n      tipo: 'asistencia',\r\n      fecha_generacion: new Date().toISOString(),\r\n      periodo: 'Noviembre 2024',\r\n      datos: {}\r\n    },\r\n    {\r\n      id: 2,\r\n      titulo: 'Reporte Académico - 10° A',\r\n      tipo: 'academico',\r\n      fecha_generacion: new Date().toISOString(),\r\n      periodo: '2024',\r\n      grado: '10°',\r\n      seccion: 'A',\r\n      datos: {}\r\n    }\r\n  ];\r\n};\r\n\r\n// guardar reporte en la base de datos\r\nexport const guardarReporte = async (\r\n  titulo: string,\r\n  tipo: 'asistencia' | 'academico' | 'conductual' | 'general',\r\n  periodo: string,\r\n  contenido: any\r\n): Promise<void> => {\r\n  const { error } = await supabase\r\n    .from('reportes')\r\n    .insert({\r\n      titulo,\r\n      tipo_reporte: tipo,\r\n      periodo,\r\n      contenido: JSON.stringify(contenido),\r\n      generado_por_tipo: 'sistema'\r\n    });\r\n\r\n  if (error) throw error;\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}